







//Circular Shift
//--------------

CLS1	MAR=SP-1;rd				// PULLS THE SECOND ENTRY IN THE STACK TO MDR
CLS2
CLS3	Z=MDR;if (Z) goto CLS18; else goto CLS4	// IF THE SECOND ENTRY IN THE STACK IS 0 WW EXIT
CLS4
CLS5	N=MDR;if (N) goto CLS29; else goto CLS6 // IF THE SECOND ENTRY IN THE STACK IS NEGATIVE THEN
	
CLS50						// WE JUMP TO CLS LABEL TO CANGE IT TO THE CORRECT POSITIVE
CLS6 	H=TOS					// THE VALUE AT THE TOP OF THE STACK IS STORE 
						// IN H
CLS7	N=H;if (N) goto CLS8; else goto CLS9
CLS8  	TOS=TOS+1				// IN CASE TOP OF THE STACK ENDS WITH A 1 WE ADD 1
CLS9 	OPC=H+TOS				// THE TOP OF THE STACK IS ADDED TO ITSELF OR TO ITSELF
						// PLUS 1
CLS10 	MDR=TOS=OPC;wr				// THE NEW SHIFTED VALUE IS PLACED IN THE TOP OF THE STACK
CLS11
CLS12	MAR=SP-1;rd				// MAR IS GOING TO POINT TO THE SECOND ENTRY
CLS13
CLS14	OPC=MDR-1				// WE DECREMENT THE SECOND VALUE
CLS15	MDR=OPC;wr				// THE NEW VALUE IS STORE IN MDR AND WRITTEN IN THE STACK
CLS16	MAR=SP					// SET MAR TO POINT TO THE FIRST VALUE
CLS17	Z=OPC;if (Z) goto CLS19; else goto CLS50	// IF THE SECOND VALUE IS ZERO WE FINISH IF NOT WE REPEAT 
	
CLS18					// THE PROCESS AGAIN
CLS19	MAR=SP-1;rd				// THE 6 FOLLOWING LINES DO A SWAP OF THE FIRST ITEM
CLS20	MAR=SP					// IN THE STACK AND THE SECOND
CLS21	H=MDR;wr
CLS22
CLS23	MDR=TOS
CLS24	MAR=SP-1;wr
CLS25	TOS=H;
CLS26	MAR=SP=SP-1;rd				// THE FOLLOWING 3 LINES DO A POP OF THE FIRST ITEM IN 
CLS27						// THE TOP OF STACK WISH WE DON'T NEED ANYMORE
CLS28	TOS=H;goto Main1

CLS29	OPC=H=1					// WE PUT 1 INTO OPC AND H
CLS30	OPC=H=H+OPC				// STORE 2 INTO H AND OPC
CLS31	OPC=H=H+OPC				// WE ADD 2 AND 2 TO STORE 4 INTO H AND OPC
CLS32	OPC=H=H+OPC				// 4+4 = 8 AND IS SOTRE IN H AND OPC
CLS33	OPC=H=H+OPC				// OPC AND H ARE GOING TO BECOME 16
CLS34	H=H+OPC					// H IS GOING TO BECOME 32
CLS35	MDR=H+MDR;wr;goto CLS5			// WE STORE THE NEW CALCULATED NUMBER IN THE SECOND ENTRY IN
						// THE STACK TO SHIFT AND JUMP TO CLS5 TO CONTINUE THE PROGRAM



//High Bit Shift
//--------------

HB1	OPC=H=1					// WE PUT 1 INTO OPC AND H
HB2	OPC=H=H+OPC				// STORE 2 INTO H AND OPC
HB3	OPC=H=H+OPC				// WE ADD 2 AND 2 TO STORE 4 INTO H AND OPC
HB4	OPC=H=H+OPC				// 4+4 = 8 AND IS SOTRE IN H AND OPC
HB5	OPC=H=H+OPC				// OPC AND H ARE GOING TO BECOME 16
HB6	OPC=OPC-1				// OPC IS GOING TO BECOME 15
HB7	H=H+OPC					// H IS GOING TO BECOME 31
HB8	LV=H					// WE STORE THE NEW CALCULATED NUMBER IN REGISTER LV
HB9	OPC=0					// SET A COUNTER TO 0
HB13   	Z=TOS;if (Z) goto HB22; else goto HB15	// IF WE FIND 0 AT THE TOP OF THE STACK THEN WE 
HB14						// GOTO HB22 AND FINISH
HB15	N=TOS;if (N) goto HB19; else goto HB16	// IF WE FIND A 1 AT THE HIGHEST THEN WE JUMP TO THE END
						// LABEL TO STORE THE INDEX IN THE TOP OF THE STACK
HB16	H=TOS;					// WE ASSIGN TOS TO H TO ADD AGAIN LATER
HB17   	TOS=TOS+H				// SHIFT BY ADDING TOP OF THE STACK TO IT SELF
HB18	LV=LV-1;goto HB14			// INCREMENT THE COUNTER AND REPEAT THE PROCESS AGAIN
	
HB19	TOS=MDR=LV;wr				// WRITING THE RESULT TO TOP OF THE STACK
HB20
  						// TO SEE IF WE FIND A 1 IN THE HIGEST BIT
HB21	goto Main1				// CALCULATE THE POSITION FROM THE LEFT TO RIGHT
HB22	MDR=-1;wr;goto Main1			// SET THE VALUE AT THE TOP OF THE STACK TO -1




//Low bit shift
//-------------

LB1	OPC=H=1					// WE PUT 1 INTO OPC AND H
LB2	OPC=H=H+OPC				// STORE 2 INTO H AND OPC
LB3	OPC=H=H+OPC				// WE ADD 2 AND 2 TO STORE 4 INTO H AND OPC
LB4	OPC=H=H+OPC				// 4+4 = 8 AND IS SOTRE IN H AND OPC
LB5	OPC=H=H+OPC				// OPC AND H ARE GOING TO BECOME 16
LB6	OPC=OPC-1				// OPC IS GOING TO BECOME 15
LB7	H=H+OPC					// H IS GOING TO BECOME 31
LB8	LV=H					// WE STORE THE NEW CALCULATED NUMBER IN REGISTER LV
LB9	OPC=0					// SET A COUNTER TO 0
LB10	MAR=SP;rd				// READ WHAT IS ON TOP OF THE STACK TO MDR
LB11
LB12	TOS=MDR;
LB13   	Z=TOS;if (Z) goto LB22; else goto LB15	// IF WE FIND 0 AT THE TOP OF THE STACK THEN WE 
						// GOTO LVxxxxxxxxx AND FINISH
LB14
LB15	Z=TOS;if (Z) goto LB19; else goto LB16	// IF TOP OF THE STACK IS ZERO WE FINISH THE LOOP
LB16	LV=LV-1					// SUBSTRACT ONE FROM LV WISH RREPRESENT THE INDEX
LB17	H=TOS;					// ASSIGN TOS TO H SO WE CAN SHIFT IN THE NEXT LINE
LB18	TOS=H+TOS;goto LB14			// SHIFTING BY ADDING TO IT SELF
LB19	TOS=MDR=LV;wr				// WE WRITE THE RESULT IN THE TOP OF THE STACK
LB20
LB21	goto Main1				// THIS IS THE EXIT OF THE PROGRAM IF WE DIDN'T FIND
						// A ZERO AT THE TOP OF THE STACK WHEN
LB22	MDR=-1;wr;goto Main1			// WE WRITE -1 TO TO THE TOP OF THE TOP OF THE STACK
						// AND FINISH THE PROGRAM

